const dataArray = data['results'];
이렇게 쓰면 fetch에서 가져온 data를 읽는데 

const dataArray = data[results];
이렇게 표현하면 undefined가 나온다 왜그럴까?

왜냐면 2번의 표현은 results 라는 변수를 찾는 형태여서 그렇다.
{key : value} pair 객체의 형태를 기억하는가?

저장할 때는 저런식이지만 사실 비밀이 하나 숨겨져있다.
{'key' : value} 사실 key의 값을 문자열이다.

JS가 굳이 문자열로 표현을 안 해도 인식을 하기 때문에
저장방법에 문자열을 추가하지는 않았지만
key 이름을 문자열 형태로 만들어서 저장해도
전혀 문제가 없다.

따라서 const dataArray = data['results']; 이렇게 호출해서 찾을 수도 있고,
data.results로 key자체를 호출하는 방식도 key값을 불려오는 방법이다.

-------------------------------------

오류할 때 너무 에러문구 보고 당황하는데
modal.style.display = 'block'; 이거 왜 안된거냐면

const modal = document.querySelector('modal');
. 이 없어서 인식자체를 못한것이다...

저렇게 스타일이 HTML에서 객체를 가지고 올때는
인식 못하면 못넘어왔다고 생각해야된다.

----------------------------------------

처음에 fetch로 데이터를 너무 받아오는게
무겁다고 생각을해서 forEach로 돌렸지만

----------------------------------------


리펙토링 필요 : 

모달에서 for문으로 이벤트 여러번 돌려썼는데
읽기에 햇갈려서 이벤트 위임으로 리펙토링 필요

-----------------------------------------

모달에서의 문제 데이터 ID를 내장시켰는데
콘솔로 찍어보니 문자열로 나옴 
그래서 else가 나온거고 else에 아무것도 없으니 안나온것.

if문 쓸 때는 else까지 쳐서
에러가 뜨는지 boolean 어떤 값인지 확인해보기
------------------------------------------

모달 닫는거에서 문제가 발생한건
클릭했을 때 바로 display:none이 주어진다.
즉 none과 block이 동시에 오가는데
addEventListener가 더 빨라서 그런지 none으로 먼저 처리한다.

문제해결 -> 
이게 forEach도 즉시실행 하기

문제2차발생

공중에 뜬줄알았는데 알고보니 공중에 안뜸..
모달을 클릭해도 바로 꺼짐

튜터님 : 
div div를 놓고 그 사이에 모달이 들어감
즉 디브 폴더안에 모달 백그라운드가 같은 선상에 있어야함
이게 상속이 되는지 몰랐음

문제해결 : 배경을 세워둬야되는데
그냥 inner_html하면 이전 요소까지 다 지워짐

결국 append를 사용해야함..

문제점 -> 추가하니까 계속 추가됨... 
결국 innerHTML을 써어함

수정방법 껍대기만 만들고
내부 내용을 넣었다 뺏다 하는 식으로 바꾸니
문제가 없었다...

내용을 수정할때도 innerHTML이다
뭔가 추가하는 개념보단 바꿀 내용을 껴넣는게 맞다.

특히 껍대기를 신경써라..
-------------------------------------------

검색기능의 문제
엔터를 눌러서 할꺼면 submit 과 eventListener
실시간 검색은 keyup을 활용해보라고 하셨다.

왜냐면 검색 api는 담겨져 있는 값이 없어서
검색을 지금 할 수가 없는 상태라고 말씀하셨다.

---------------------------------------

gird에서 마지막 2칸은 중앙으로 옮겨야 했는데

grid-row : 2 / span 2;

2번을 시작으로 + 2만큼의 공간을 차지
즉 객체가 공간을 차지 하는게 아닌
그리드 라인에서 조종하는 css

----------------------------------------

검색 api가 작동이 안되는 이유
아래 required로 쓰인 query가 검색을 받는
url의 한부분인데
그래서 query = deadfool  라고 하면
검색결과가 url을 타고 잘 출력된다
내가 구현해야되는 써치는 이런 파트이다

문제 발생
실시간으로 value값이 변환되야 원하는 텍스트에
맞출 수 있는데 value값이 한글자만 쳐도 고정됨
결국 제어가 필요한데 forEach는 제어가 잘 안됨
그래서 for문으로 바꿔보았다.

destructoring 문법
key 값이 무조건 똑같아야 함

{poster_path:(바꾸고싶은 이름)} = db

-------------------------------------

북마크 기능 오류...

for () {
}
qquerySelectorAll(버튼클래스)
addEventlistner
형태로 진행하니 클릭이 안먹는데

알고보니 이 querySelectorAll가 클릭 되기도 전에
먼저 생성을 해버리니
이미 없는 상태에서 클릭이벤트는 클릭을 해야 작동되는데
클릭할 대상이 없으니 클릭조차 잡히지 않는 것

const 같은 변수는 클릭하면 실행되는 친구들보다
먼저 읽히기 때문에 클릭했을 때 변수가 읽히게 만들어야 한다

즉 지금 한 함수안에 너무 많은게 들어가있어서
순서대로 배열해주면 읽어줄 거임.

기능을 나열해주는것
얘를들어
function loadData() {
	fetch("",API_OPTION).then(response => response.json())
	.then(res => {
		renderData();
		bindModalEvent();
	})
}

데이터 loadData하고 renderData는 화면에 보여주는거
bindModalEvent는 renderData를 싸그리 끌어와 bindModalEvent로 만들고
해야지 클릭도 먹을 것이다.
--------------------------------------
튜터님 조언 : 

키워드 검색도 api 키워드를 넣을 수 있게 되어있다.
검색하는 부분에 대해서는 함수를 만들어놓는것 search

실행되었을 때 api를 요청해서 키워드가 표현된.
어차피 맨 처음에 모든 데이터를 가져오는 응답값도
그냥 배열에 영화정보가 들어있다
키워드로 검색했을 때도 응답값도 배열에 들어있다.
결국 위나 아래의 다음 로직은 똑같다
응답값안에 있는 배열 영화데이터가 들어있는 배열을
map이나 forEach로 불러주기
appendChild하는 로직을 함수로 분리할 수 있을 거다.

렌더무비데이터 매개변수를 배열이 받도록.
----------------------------------


북마크 기능

지금 api 2개 따로 관리중인데
함수에 북마크 추가 삭제 기능 만들고
버튼 누르면 북마크 된 값들 불러오기

로컬스토리지 알아야 할 점
로컬스토리지는 브라우저 안에 있는 저장소
f12 application 에 local storage가 있음

localStorage.setItem('example-key',10);
getItem으로 key로 접근해서 value로 가져오기

로컬스토리지 안에 있는 것들은 문자열임
(배열이나 객체처럼 보이지만 jSON 문자열 형태임)

타입변환을 신경써줘야 함 그래서

setItem을 참조형 데이터로 넣었다고 가정하면?
참조형 데이터를 그냥 넣게 되면 변환이 안됨
이 데이터를 문자열화 시켜줘야 하는게 특징임
Json.stringify({a:10});

Local storage에서는 모두 json의 문자열 형태
브라우저가 보이게 편하라고 보여준거지

--------------------

검색은 결국에 필터링은
tmdb에 있는 영화 데이터들은 몇백만개의 영화가 있다.

몇백만개를 필터링해서 보여주고 있음 지금
tmdb는 최초에 기준 20개만 보여줌

20개를 받아와서 그 20개에서 필터링

타이핑을 할 때마다 인터넷을 이용해야 해서
보통 상업적으로 하면 구조는 비슷한데

그러기 위해서 필요한 게 디바운싱인데 그냥 있다 정도만

타이핑시간에 제약을 줘서
어느 정도의 텀이 생겨야
api요청을 날라가게 할 수도 있음.

사용자가 이벤트 사용을 멈췄을 때 디바운싱

f12에서 네트워크 들어가면 어떻게 사용되는지 볼 수 있음
---------------------------------------

어렵지는 않은데 주변을 잘 살피고 이용할줄 알아야 한다.


함수 만드는 원칙 => 수정 사항

한 함수가 한번에 하나의 역할만 하게 하면 좋아진다.
두번째는 함수가 외부변수를 참조하지 않게 한다면
로직이 좋아진다.

ex) x10 함수가 있다면 1을 넣으면 항상 10만 나오게
예상 가능하게 움직이게 한다면.

함수가 외부변수를 참조한다면

함수 안에서 외부변수를 참조하려 한다면
95줄도 매게변수로 받을 수가 있다.

중간과정()데이터를 그려주는 기능은 함수로 만들어도 됨.
예를 그려주는 기능은 필요가 없다

response.date -> forEach element 만들어주고 <div class ='card'> 하는거 말고 없다
그냥 그려주는 함수에서 모달을 열어주는 로직을 추가시켜도 된다.
그냥 카드안에 dataset 을 넣어놓아도 된다.

그려주는 함수는 그려주기만 하자

이 함수가 끝난다음에 함수를 하나 만들어주는 것
그려진 카드들을 다 모아올 수 있겠죠 document.querySelectorAll

1. 영화데이터를 불러오는 함수만 먼저 실행을 시킵니다.
2. 예를 그려주는 함수를 실행시킵니다.
3. 다 그려졌으니까 그려진 카드들을 다 모아서 모달 만들어주는 이벤트
검색의 경우 ?

function loadData() {
	fetch("",API_OPTION).then(response => response.json())
	.then(res => {
		renderData();
		bindModalEvent();
	})
}

fetch는 기본적으로 제공이 되는 build in 메서드임
aysnc는 패키지를 설치를 따로 해줘야 한다.

next.js에서는 fech와 잘 어울림
외부 라이브러리를 쓰는걸 좀 민감함






