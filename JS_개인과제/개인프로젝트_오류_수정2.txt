모듈화를 사용하는 이유는

html이 여러개 있을 때도
필요한 로직들만 가져와 사용할 수 있게

즉 불필요한 것까지 다 불러오지 않게 하기 위해
필요한 것들만 모듈화를 시켜서 저장한다.

새로운 html에서 사용하려면

function searchMoive()라 얘를 들었는데
document.getElementById()로 불러오기보다
이것보다 메게변수로 받아와야지

모듈화는 레고로 예를 들면
어디에 다 껴도 작동이 되게끔 만드는게
제대로 된 모듈화다.

즉 모듈화를 할 때는 어디서든 사용가능한지를
인지하고 만들어 봐야 함

--------------------------------

새로고침하자마자 target의 오류가 뜨는 이유

searchInput.addEventListener("input", updateValue);
이벤트 객체가 자동으로 들어가기 때문에
input에 입력될 때 실행되게 세팅이 되어 있다.

따라서 아래에 updateValue() 를 실행하면 2번 실행한 것과 똑같다.

-------------------------------

북마크 문제 따로 관리하려면 다른 방식으로 접근해야함
지금 내가 만든 방식 그대로 복사해서 붙여넣는 방식에선

querySelector을 했을 때는 생성되고 동적인 함수로 접근해야 되서
비동기로 접근했을 때 안집히기 때문에 내부안에서 처리해야 함

---------------------------------

localstorage 를
배열 형태로 저장해서 굳이 아래로 안늘어지게 만드는 것

현재 문제는 클릭할 때마다 초기화 되어서 push를 먹일 수 있게 만들어 보기

로컬스토리지 주의점 2

1. getItem 으로 불러올 때 항상 없을 수도 있는 초기 값을 생각할 것
지금처럼 저장하려는 값이 [] 이라면 빈 배열을 잡아주면 됨
객체라면 빈 객체 {} 를 설정해주면 됨
문자열도 마찬가지로 빈 문자열
숫자라면 0을 주는 방식으로 
값이 null 이나 undefined라도 getItem에서 터지지 않게 초기값 만들기

2. localstorage는 항상 문자열로 저장되기 때문에
json stringfy json parse로

localstorage를 사용한다하면
변수랑 똑같이 생각하면 됨 
storage === 저장공간

무언가 가지러 오려 할 때 아무것도 없으면 가져올 수 있다.
먼저 데이터를 저장해주어야 한다.
변수 a를 선언해주는 것처럼

localstorage나 세션스토리지도 마찬가지로
선언할 때 첫번째는 키값 두번째는 value 값

첫번째 것이 선행이 되어야 getItem으로 불러올 수 있다.
우리가 브라우저를 껏다 켯을 때 이 값을 확인하고 싶은 경우가 많다.

장바구니 , 1주일 동안 팝업 보지 않기
데이터를 쓰기 전에 있는 데이터를 먼저 가져오려고 한다.

먼저 데이터를 쓰기 위해서는 써줘야 한데
가져오려다 보니 문제가 생김

로컬스토리지는 꺼도 데이터가 이전에 남아있지만
최초 실행시에는 항상 key 값이 없기에 문제가 된다.

최초에 key 값이 없을 때 그냥 예외처리를 한번 해준다.
그래서 위의 삼항연산자는 id가 만들어진 이후부터는 쓰일 이유가 없다
항상 저장을 되어 있으니까 저 값을 가지고 온다.

그러나 처음 쓰는 사람들한테 저 삼항연산자 로직이 필요한 것이다.

즉 
const storage = localStorage.setItem('data-id', JSON.stringify([]));
localStorage가 계속해서 빈배열을 만들어내기 때문에
처음에 if문으로 한번 생성을 해주는 제어문이 하나가 필요하다.

----------------------------------------------

if (bookMarkitems.includes(getDataValue)) {      
                const items = bookMarkitems.filter((id)=>{
                    if (Number(id) === Number(getDataValue)) {
                        return false;
                    } else {
                        return true;
                    }
                })
                localStorage.setItem('dataId-list', JSON.stringify(items));
            } else {
            bookMarkitems.push(getDataValue);
            localStorage.setItem('dataId-list', JSON.stringify(bookMarkitems));
}
튜터님의 조언에 따라
filter를 사용해서 바로 이 안에서도 사용이 가능했고,
filter를 사용해 데이터를 새로운 변수에 반환하는 방식으로 사용했다.

filter는 boolean 타입만 반환하기 때문에
return을 false할 것인지 true 할 것인지를 정하는 방식으로 접근
bookMarkitems.filter 에서 조건문을 걸어서 true false 값을 받고 return했고
여기서 중요한건 true일 때 filter는 반환을 해준다.
따라서 items라는 변수에 filter의 값을 true의 값을 받아주었고,
true의 값을 받았기에 filter 한 위의 조건 includes에서 getDataValue를 제거 받고
제거한 새로운 배열을 items가 가지고 있다.
그리고 localStorage에 .setItem으로 새롭게 업데이트 해주면 된다.
따라서 새로고침을 하면 북마크에서 제거된걸 확인해볼 수 있었다.

----------------------------------------------

검색 된 값에 따라서만 현재 정보를 찾아주기 때문에
이를 해결하려면 forEach로 다 읽어줘야 한다 지금 상황에서는
사실 원래는 배열에 담아야하지만 현재 한번에 해결하려면 이 방식도 틀리지 않는다

-------------------------------------------------

현재 api를 id값만 가지고 1나씩 보여주는 api로 북마크를 제작하는데
현재 forEach를 돌렸더니 문제가 발생함
알고보니 예는 data.result 즉 result 안에 배열이 있는게 아니였음...
그렇기 때문에 그냥 포문 자체로도 구현이 가능함 
무슨 말이냐면 한번 담아서 쓸 필요 없이
바로 사용이 가능하다.
왜? 양이 많지 않고 객체로 이루어져 있기 때문에

데이터가 2번씩이나 떴던 이유
아래 bookMarkRend()를 써놓고
한번더 클릭하면 실행되서 총 2번 실행되었기 때문이다.

-------------------------------------------

모달이 실행되지 않았던 문제는
querySelectorAll로 addeventListener를 부여하면
클릭했을 때 부여되기 때문에
1번을 클릭했다면 만약 똑같은 이벤트를 가지고 있는게 5개라면
5번이 덫씌워지는 현상이 생긴다.

따라서 event를 부여하기에 가장 안전한 방법은
객체를 만들어낼 때 그 때 이벤트를 심어놓고

 movieCard.className = 'movieCard';
 movieCard.dataset.id = posterId;
movieCard.innerHTML = 추가할 요소
movieCard.addEVentListener(){}
이런식으로 생성하고 이벤트를 부여하고 나서

마지막에 appendChild로 생성시킨다

즉 이벤트를 미리 심어놓은 상태로 생성을 하게 만들어야 한다.

마찬가지로 지금도 클릭 이벤트에 문제가 생긴게
이게 이벤트를 클릭할 때마다 다 퍼트리는게 아니라
클릭하고 remove를 해줘서 꺼줘야 하는데
문제가 너무 크다...

[Violation] 'click' handler took 1275ms
오류가 나오는데
이게 지금 계속 생성될 때 마다 생성된 값 만큼 이벤트 리스너가
cctv가 한번에 전체를 봐야되는데
cctv가 사람 한명씩을 1대당 1명을 감시하는 꼴이다

에러나 문제가 생기기 이전에
console 로 홈페이지에서 찍는 습관을 확인해보자

-------------------------------

걍 싹다 다시 함 


